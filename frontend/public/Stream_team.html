<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Stream Team - Create and manage movie watching groups with your friends on MovieNightPlanner.">
    <meta property="og:title" content="Stream Team - MovieNightPlanner">
    <meta property="og:description" content="Create and manage movie watching groups with your friends on MovieNightPlanner.">
    <meta property="og:type" content="website">
    <link rel="canonical" href="Stream_team.html">
    <title>Stream Team - MovieNightPlanner</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="css/pages/stream-team.css">
</head>
<body>
    <header class="header">
        <a href="website.html" class="logo-link" aria-label="MovieNightPlanner home">
            <h1 class="logo">MovieNightPlanner</h1>
        </a>
        <nav class="main-nav" aria-label="Main navigation">
            <a href="website.html">Home</a>
            <a href="Binge_Bank.html">Binge Bank</a>
            <a href="Stream_team.html">Stream Team</a>
            <a href="Friends.html">Friends</a>
            <a href="heads_up.html">Heads Up</a>
            <a href="Setting.html">Settings</a>
        </nav>
        <div class="nav-auth">
            <a href="Log_In.html" id="loginLink" class="nav-auth-btn nav-auth-ghost">Log In</a>
            <a href="Sign_Up.html" id="signUpLink" class="nav-auth-btn nav-auth-primary">Sign Up</a>
            <button type="button" id="logoutLink" class="nav-auth-btn nav-auth-primary" style="display:none;">Sign Out</button>
        </div>
    </header>

    <main class="st-main">
        <section class="st-header card" data-animate>
            <div>
                <h2>Your Stream Teams</h2>
                <p>Create groups, vote on watchlists, and schedule nights from one workspace.</p>
            </div>
            <button class="btn btn-primary" id="createGroupBtn" type="button">Create New Group</button>
        </section>

        <section id="content" data-animate></section>

        <section id="groupDetail" class="group-detail card" data-animate>
            <div class="group-detail-header">
                <div class="group-detail-heading">
                    <h3 class="group-detail-title" id="groupDetailTitle">Group Name</h3>
                    <p class="group-detail-role" id="groupDetailRole">Role: Member</p>
                </div>
                <button class="btn btn-secondary" id="backToGroups" type="button">Back to Groups</button>
            </div>

            <div class="detail-tabs">
                <button class="detail-tab" type="button" data-tab="members">Members</button>
                <button class="detail-tab active" type="button" data-tab="watchlist">Watchlist</button>
                <button class="detail-tab" type="button" data-tab="movieNights">Movie Nights</button>
            </div>

            <div id="membersTab" class="tab-content">
                <div class="success-message" id="memberSuccess" aria-live="polite"></div>
                <div class="error-message" id="memberError" aria-live="assertive"></div>
                <p class="members-permission-hint" id="memberPermissionHint"></p>

                <div class="add-member-form card">
                    <h4>Invite Member</h4>
                    <div class="add-member-row">
                        <label for="memberEmailInput" class="sr-only">Member email</label>
                        <input type="email" id="memberEmailInput" placeholder="friend@example.com">
                        <button class="btn btn-primary" id="addMemberBtn" type="button">Invite</button>
                    </div>
                </div>

                <ul class="members-list" id="membersList"></ul>
            </div>

            <div id="watchlistTab" class="tab-content active">
                <div class="watchlist-header">
                    <h4>Group Watchlist</h4>
                    <a href="Binge_Bank.html" class="btn btn-primary">Add Movies</a>
                </div>
                <div class="watchlist-voting-grid" id="watchlistVotingGrid"></div>
            </div>

            <div id="movieNightsTab" class="tab-content">
                <div class="success-message" id="movieNightSuccess" aria-live="polite"></div>
                <div class="error-message" id="movieNightError" aria-live="assertive"></div>

                <div class="create-movie-night-form card">
                    <div class="movie-night-form-header">
                        <h4>Schedule Movie Night</h4>
                        <p>Pick a calendar date, set a start time, and export invites in one click.</p>
                    </div>
                    <div class="movie-night-date-row">
                        <div class="form-group">
                            <label for="movieNightDate">Calendar Date</label>
                            <input type="date" id="movieNightDate">
                        </div>
                        <div class="form-group">
                            <label for="movieNightTime">Start Time</label>
                            <input type="time" id="movieNightTime" value="20:00">
                        </div>
                    </div>
                    <p class="movie-night-selected-preview" id="movieNightSelectedPreview">No date selected yet.</p>
                    <div class="movie-night-date-row">
                        <div class="form-group">
                            <label for="rsvpDeadlineDate">RSVP Deadline Date (optional)</label>
                            <input type="date" id="rsvpDeadlineDate">
                        </div>
                        <div class="form-group">
                            <label for="rsvpDeadlineTime">RSVP Deadline Time (optional)</label>
                            <input type="time" id="rsvpDeadlineTime" value="18:00">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="rsvpReminderMinutes">Reminder Timing</label>
                        <select id="rsvpReminderMinutes">
                            <option value="">No automatic reminder</option>
                            <option value="1440">24 hours before</option>
                            <option value="360">6 hours before</option>
                            <option value="120">2 hours before</option>
                            <option value="60">1 hour before</option>
                            <option value="30">30 minutes before</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="chosenMovie">Movie (optional)</label>
                        <select id="chosenMovie">
                            <option value="">Select a movie from watchlist...</option>
                        </select>
                    </div>
                    <button id="createMovieNightBtn" class="btn btn-primary" type="button">Schedule Movie Night</button>
                </div>

                <div class="movie-night-plans card">
                    <div class="movie-night-plans-header">
                        <h4>Planned Movie Nights</h4>
                        <span class="movie-night-plan-count" id="movieNightPlanCount">0 planned</span>
                    </div>
                    <ul class="movie-nights-list" id="movieNightsList"></ul>
                </div>

                <div class="movie-night-calendar card">
                    <div class="movie-night-calendar-header">
                        <button class="btn btn-ghost" id="calendarPrevMonth" type="button" aria-label="Previous month">Previous</button>
                        <h5 id="calendarMonthLabel">Calendar</h5>
                        <button class="btn btn-ghost" id="calendarNextMonth" type="button" aria-label="Next month">Next</button>
                    </div>
                    <div class="calendar-weekdays" aria-hidden="true">
                        <span>Sun</span>
                        <span>Mon</span>
                        <span>Tue</span>
                        <span>Wed</span>
                        <span>Thu</span>
                        <span>Fri</span>
                        <span>Sat</span>
                    </div>
                    <div class="calendar-grid" id="movieNightCalendarGrid"></div>
                    <p class="calendar-day-summary" id="calendarDaySummary">Select a day to schedule a movie night.</p>
                </div>
            </div>
        </section>
    </main>

    <div id="createModal" class="modal" style="display:none;">
        <div class="modal-content">
            <button class="modal-close close" aria-label="Close" type="button">x</button>
            <h3>Create a New Group</h3>
            <div class="error-message" id="createGroupError" aria-live="assertive"></div>
            <label for="groupNameInput" class="sr-only">Group name</label>
            <input type="text" id="groupNameInput" placeholder="Enter group name" maxlength="100">
            <button id="confirmCreateBtn" class="btn btn-primary" type="button">Create Group</button>
        </div>
    </div>

    <script src="app.js"></script>
    <script>
        let currentGroupId = null;
        let currentGroupRole = 'member';
        let currentGroupName = '';
        let groupsCache = [];
        let movieNightsCache = [];
        let calendarViewDate = new Date(new Date().getFullYear(), new Date().getMonth(), 1);
        const GROUP_ROLE_ORDER = { member: 1, moderator: 2, owner: 3 };

        const content = document.getElementById('content');
        const createGroupBtn = document.getElementById('createGroupBtn');
        const createModal = document.getElementById('createModal');
        const groupDetail = document.getElementById('groupDetail');
        const groupNameInput = document.getElementById('groupNameInput');
        const confirmCreateBtn = document.getElementById('confirmCreateBtn');
        const backToGroups = document.getElementById('backToGroups');

        const groupDetailTitle = document.getElementById('groupDetailTitle');
        const groupDetailRole = document.getElementById('groupDetailRole');
        const membersList = document.getElementById('membersList');
        const memberPermissionHint = document.getElementById('memberPermissionHint');
        const watchlistVotingGrid = document.getElementById('watchlistVotingGrid');
        const movieNightsList = document.getElementById('movieNightsList');
        const movieNightPlanCount = document.getElementById('movieNightPlanCount');
        const movieNightDateInput = document.getElementById('movieNightDate');
        const movieNightTimeInput = document.getElementById('movieNightTime');
        const rsvpDeadlineDateInput = document.getElementById('rsvpDeadlineDate');
        const rsvpDeadlineTimeInput = document.getElementById('rsvpDeadlineTime');
        const rsvpReminderMinutesInput = document.getElementById('rsvpReminderMinutes');
        const movieNightSelectedPreview = document.getElementById('movieNightSelectedPreview');
        const calendarMonthLabel = document.getElementById('calendarMonthLabel');
        const movieNightCalendarGrid = document.getElementById('movieNightCalendarGrid');
        const calendarDaySummary = document.getElementById('calendarDaySummary');
        const calendarPrevMonth = document.getElementById('calendarPrevMonth');
        const calendarNextMonth = document.getElementById('calendarNextMonth');

        document.addEventListener('DOMContentLoaded', async () => {
            await ensureAuthState();
            initializeMovieNightScheduler();
            loadGroups();
            setupEventListeners();
        });

        function normalizeCollection(result) {
            if (Array.isArray(result)) return result;
            if (result && Array.isArray(result.data)) return result.data;
            return [];
        }

        function normalizeRole(role) {
            if (role === 'owner' || role === 'moderator' || role === 'member') return role;
            return 'member';
        }

        function hasMinimumRole(minimumRole) {
            return (GROUP_ROLE_ORDER[currentGroupRole] || 0) >= (GROUP_ROLE_ORDER[minimumRole] || 0);
        }

        function formatRole(role) {
            const normalized = normalizeRole(role);
            return normalized.charAt(0).toUpperCase() + normalized.slice(1);
        }

        function initializeMovieNightScheduler() {
            const today = new Date();
            const todayString = toDateInputValue(today);
            movieNightDateInput.min = todayString;
            rsvpDeadlineDateInput.min = todayString;
            if (!movieNightTimeInput.value) movieNightTimeInput.value = '20:00';
            if (!rsvpDeadlineTimeInput.value) rsvpDeadlineTimeInput.value = '18:00';
            updateSelectedDatePreview();
            renderMovieNightCalendar([]);
        }

        function toDateInputValue(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function parseDateValue(value) {
            if (!value) return null;
            if (value instanceof Date) return value;
            const raw = String(value);
            const normalized = raw.includes(' ') ? raw.replace(' ', 'T') : raw;
            const parsed = new Date(normalized);
            return Number.isNaN(parsed.getTime()) ? null : parsed;
        }

        function toDateKey(date) {
            return toDateInputValue(date);
        }

        function buildSelectedDateTime() {
            const dateValue = movieNightDateInput.value;
            if (!dateValue) return null;
            const timeValue = movieNightTimeInput.value || '20:00';
            return `${dateValue}T${timeValue}`;
        }

        function buildRsvpDeadlineDateTime() {
            const dateValue = rsvpDeadlineDateInput.value;
            if (!dateValue) return null;
            const timeValue = rsvpDeadlineTimeInput.value || '18:00';
            return `${dateValue}T${timeValue}`;
        }

        function handleMovieNightDateChange() {
            if (movieNightDateInput.value) {
                const selectedDate = parseDateValue(`${movieNightDateInput.value}T12:00`);
                if (selectedDate) {
                    calendarViewDate = new Date(selectedDate.getFullYear(), selectedDate.getMonth(), 1);
                }
            }
            updateSelectedDatePreview();
            renderMovieNightCalendar(movieNightsCache);
        }

        function updateSelectedDatePreview() {
            const dateTimeValue = buildSelectedDateTime();
            rsvpDeadlineDateInput.max = movieNightDateInput.value || '';
            if (!dateTimeValue) {
                movieNightSelectedPreview.textContent = 'No date selected yet.';
                updateCalendarDaySummary();
                return;
            }

            const selectedDate = parseDateValue(dateTimeValue);
            if (!selectedDate) {
                movieNightSelectedPreview.textContent = 'Selected date is invalid.';
                updateCalendarDaySummary();
                return;
            }

            const formatted = selectedDate.toLocaleString([], {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
            });
            let previewText = `Selected: ${formatted}`;

            const rsvpDateTimeValue = buildRsvpDeadlineDateTime();
            if (rsvpDateTimeValue) {
                const rsvpDate = parseDateValue(rsvpDateTimeValue);
                if (rsvpDate) {
                    const deadlineFormatted = rsvpDate.toLocaleString([], {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric',
                        hour: 'numeric',
                        minute: '2-digit',
                    });
                    previewText += ` | RSVP closes: ${deadlineFormatted}`;
                } else {
                    previewText += ' | RSVP deadline is invalid';
                }
            }

            movieNightSelectedPreview.textContent = previewText;
            updateCalendarDaySummary(movieNightDateInput.value);
        }

        function shiftCalendarMonth(offset) {
            calendarViewDate = new Date(calendarViewDate.getFullYear(), calendarViewDate.getMonth() + offset, 1);
            renderMovieNightCalendar(movieNightsCache);
        }

        function countNightsByDate(movieNights) {
            return movieNights.reduce((acc, night) => {
                const date = parseDateValue(night.scheduled_date);
                if (!date) return acc;
                const key = toDateKey(date);
                acc[key] = (acc[key] || 0) + 1;
                return acc;
            }, {});
        }

        function renderMovieNightCalendar(movieNights) {
            const nightsByDate = countNightsByDate(movieNights);
            const year = calendarViewDate.getFullYear();
            const month = calendarViewDate.getMonth();
            const firstDayOffset = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const selectedDate = movieNightDateInput.value;
            const todayKey = toDateKey(new Date());

            calendarMonthLabel.textContent = calendarViewDate.toLocaleDateString([], {
                month: 'long',
                year: 'numeric',
            });

            let html = '';
            for (let i = 0; i < firstDayOffset; i += 1) {
                html += '<span class="calendar-day calendar-day-empty" aria-hidden="true"></span>';
            }

            for (let day = 1; day <= daysInMonth; day += 1) {
                const dateKey = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const hasNight = Boolean(nightsByDate[dateKey]);
                const classes = [
                    'calendar-day',
                    hasNight ? 'has-night' : '',
                    selectedDate === dateKey ? 'selected' : '',
                    todayKey === dateKey ? 'today' : '',
                ].filter(Boolean).join(' ');

                html += `
                    <button class="${classes}" data-date="${dateKey}" type="button">
                        <span class="calendar-day-number">${day}</span>
                        ${hasNight ? `<span class="calendar-day-count">${nightsByDate[dateKey]}</span>` : ''}
                    </button>
                `;
            }

            movieNightCalendarGrid.innerHTML = html;
            movieNightCalendarGrid.querySelectorAll('.calendar-day[data-date]').forEach((dayButton) => {
                dayButton.addEventListener('click', () => {
                    movieNightDateInput.value = dayButton.dataset.date;
                    updateSelectedDatePreview();
                    renderMovieNightCalendar(movieNightsCache);
                });
            });

            updateCalendarDaySummary(selectedDate);
        }

        function updateCalendarDaySummary(dateKey = '') {
            if (!dateKey) {
                calendarDaySummary.textContent = 'Select a day to schedule a movie night.';
                return;
            }

            const selectedNights = movieNightsCache.filter((night) => {
                const parsed = parseDateValue(night.scheduled_date);
                return parsed && toDateKey(parsed) === dateKey;
            });

            if (selectedNights.length === 0) {
                const selectedDate = parseDateValue(`${dateKey}T12:00`);
                const label = selectedDate
                    ? selectedDate.toLocaleDateString([], { weekday: 'long', month: 'short', day: 'numeric' })
                    : dateKey;
                calendarDaySummary.textContent = `No scheduled movie nights on ${label}.`;
                return;
            }

            const summary = selectedNights
                .slice(0, 2)
                .map((night) => {
                    const startAt = parseDateValue(night.scheduled_date);
                    const timeLabel = startAt
                        ? startAt.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })
                        : 'Time TBD';
                    return night.movie_title
                        ? `${timeLabel} - ${night.movie_title}`
                        : `${timeLabel} - Movie TBD`;
                })
                .join(' | ');

            const moreCount = selectedNights.length > 2 ? ` (+${selectedNights.length - 2} more)` : '';
            calendarDaySummary.textContent = `${selectedNights.length} scheduled: ${summary}${moreCount}`;
        }

        function formatRelativeDuration(ms) {
            const totalMinutes = Math.max(1, Math.round(Math.abs(ms) / 60000));
            const days = Math.floor(totalMinutes / (24 * 60));
            const hours = Math.floor((totalMinutes % (24 * 60)) / 60);
            const minutes = totalMinutes % 60;

            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }

        function formatRsvpCountdown(deadlineValue) {
            if (!deadlineValue) return 'No RSVP deadline set';
            const deadline = parseDateValue(deadlineValue);
            if (!deadline) return 'RSVP deadline unavailable';

            const diffMs = deadline.getTime() - Date.now();
            if (diffMs >= 0) return `RSVP closes in ${formatRelativeDuration(diffMs)}`;
            return `RSVP closed ${formatRelativeDuration(diffMs)} ago`;
        }

        function renderAwaitingMembersChips(night) {
            const awaitingMembers = Array.isArray(night.awaiting_members) ? night.awaiting_members : [];
            if (awaitingMembers.length === 0) {
                return '<span class="awaiting-chip is-clear">Everyone responded</span>';
            }

            const chips = awaitingMembers.slice(0, 3)
                .map((name) => `<span class="awaiting-chip">${escapeHtml(name)}</span>`)
                .join('');
            const extra = awaitingMembers.length > 3
                ? `<span class="awaiting-chip">+${awaitingMembers.length - 3} more</span>`
                : '';
            return chips + extra;
        }

        function formatReminderLeadLabel(minutes) {
            const value = Number(minutes);
            if (!Number.isFinite(value) || value <= 0) return 'No reminder configured';
            if (value % 1440 === 0) {
                const days = value / 1440;
                return `${days} day${days === 1 ? '' : 's'} before`;
            }
            if (value % 60 === 0) {
                const hours = value / 60;
                return `${hours} hour${hours === 1 ? '' : 's'} before`;
            }
            return `${value} minutes before`;
        }

        function setupEventListeners() {
            document.querySelectorAll('.close').forEach((closeBtn) => {
                closeBtn.addEventListener('click', () => {
                    closeBtn.closest('.modal').style.display = 'none';
                });
            });

            window.addEventListener('click', (event) => {
                if (event.target.classList.contains('modal')) {
                    event.target.style.display = 'none';
                }
            });

            createGroupBtn.addEventListener('click', () => {
                if (!checkAuth()) {
                    window.location.href = 'Log_In.html';
                    return;
                }
                createModal.style.display = 'flex';
                groupNameInput.value = '';
                groupNameInput.focus();
            });

            confirmCreateBtn.addEventListener('click', handleCreateGroup);
            groupNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleCreateGroup();
            });

            backToGroups.addEventListener('click', () => {
                groupDetail.classList.remove('active');
                loadGroups();
            });

            document.querySelectorAll('.detail-tab').forEach((tab) => {
                tab.addEventListener('click', () => switchTab(tab.dataset.tab));
            });

            document.getElementById('addMemberBtn').addEventListener('click', handleAddMember);
            document.getElementById('memberEmailInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleAddMember();
            });
            membersList.addEventListener('change', handleMemberRoleChange);
            membersList.addEventListener('click', handleMemberRemoval);

            document.getElementById('createMovieNightBtn').addEventListener('click', handleCreateMovieNight);
            movieNightDateInput.addEventListener('change', handleMovieNightDateChange);
            movieNightTimeInput.addEventListener('change', updateSelectedDatePreview);
            rsvpDeadlineDateInput.addEventListener('change', updateSelectedDatePreview);
            rsvpDeadlineTimeInput.addEventListener('change', updateSelectedDatePreview);
            calendarPrevMonth.addEventListener('click', () => shiftCalendarMonth(-1));
            calendarNextMonth.addEventListener('click', () => shiftCalendarMonth(1));
            movieNightsList.addEventListener('click', handleMovieNightsListActions);
        }

        async function loadGroups() {
            if (!checkAuth()) {
                content.innerHTML = `
                    <div class="login-prompt card">
                        <h3>Please log in to view your groups</h3>
                        <p>Join or create movie groups with your friends.</p>
                        <p><a href="Log_In.html">Log In</a> or <a href="Sign_Up.html">Sign Up</a></p>
                    </div>
                `;
                createGroupBtn.style.display = 'none';
                return;
            }

            createGroupBtn.style.display = '';

            try {
                const groups = normalizeCollection(await getGroups());
                groupsCache = groups.map((group) => ({
                    ...group,
                    user_role: normalizeRole(group.user_role || (Number(group.created_by) === Number(currentUser?.id) ? 'owner' : 'member')),
                }));
                if (!checkAuth()) {
                    content.innerHTML = `
                        <div class="login-prompt card">
                            <h3>Please log in to view your groups</h3>
                            <p>Join or create movie groups with your friends.</p>
                            <p><a href="Log_In.html">Log In</a> or <a href="Sign_Up.html">Sign Up</a></p>
                        </div>
                    `;
                    createGroupBtn.style.display = 'none';
                    return;
                }
                if (groups.length === 0) {
                    content.innerHTML = `
                        <div class="empty-state card">
                            <h3>No groups yet</h3>
                            <p>Create your first group to start planning movie nights.</p>
                        </div>
                    `;
                    return;
                }
                displayGroups(groupsCache);
            } catch (error) {
                content.innerHTML = '<div class="empty-state card"><h3>Error loading groups</h3><p>Please refresh and try again.</p></div>';
            }
        }

        function displayGroups(groups) {
            const grid = document.createElement('div');
            grid.className = 'groups-grid';

            groups.forEach((group) => {
                const card = document.createElement('article');
                card.className = 'group-card card animate-fade-in-up';
                card.innerHTML = `
                    <div class="group-name">${escapeHtml(group.group_name)}</div>
                    <div class="group-info">
                        Created: ${formatDate(group.created_at)}<br>
                        Creator: ${escapeHtml(group.creator_name || 'Unknown')}<br>
                        Your role: ${formatRole(group.user_role)}
                    </div>
                    <div class="group-actions">
                        <button class="btn btn-secondary js-members" type="button">View Members</button>
                        <button class="btn btn-primary js-enter" type="button">Enter Group</button>
                    </div>
                `;

                card.querySelector('.js-members').addEventListener('click', () => enterGroup(group));
                card.querySelector('.js-enter').addEventListener('click', () => enterGroup(group));
                grid.appendChild(card);
            });

            content.innerHTML = '';
            content.appendChild(grid);
        }

        async function handleCreateGroup() {
            const groupName = groupNameInput.value.trim();
            const errorDiv = document.getElementById('createGroupError');
            if (!groupName) {
                showError(errorDiv, 'Please enter a group name');
                return;
            }

            try {
                await createGroup(groupName);
                createModal.style.display = 'none';
                showSuccess(null, 'Group created successfully');
                loadGroups();
            } catch (error) {
                showError(errorDiv, error.message || 'Failed to create group');
            }
        }

        async function enterGroup(group) {
            currentGroupId = group.group_id;
            currentGroupName = group.group_name;
            currentGroupRole = normalizeRole(group.user_role);
            groupDetailTitle.textContent = currentGroupName;
            groupDetailRole.textContent = `Role: ${formatRole(currentGroupRole)}`;
            groupDetail.classList.add('active');
            await loadWatchlistMovies();
            switchTab('watchlist');
        }

        function syncCurrentGroupRoleFromCache() {
            const cachedGroup = groupsCache.find((group) => Number(group.group_id) === Number(currentGroupId));
            if (!cachedGroup) return;
            currentGroupRole = normalizeRole(cachedGroup.user_role);
            currentGroupName = cachedGroup.group_name || currentGroupName;
            groupDetailTitle.textContent = currentGroupName;
            groupDetailRole.textContent = `Role: ${formatRole(currentGroupRole)}`;
        }

        function switchTab(tabName) {
            const tabIdMap = {
                members: 'membersTab',
                watchlist: 'watchlistTab',
                movieNights: 'movieNightsTab'
            };

            document.querySelectorAll('.detail-tab').forEach((tab) => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            document.querySelectorAll('.tab-content').forEach((tab) => {
                tab.classList.remove('active');
            });

            const targetTab = document.getElementById(tabIdMap[tabName] || `${tabName}Tab`);
            if (targetTab) targetTab.classList.add('active');

            if (tabName === 'members') loadMembers();
            if (tabName === 'watchlist') loadWatchlist();
            if (tabName === 'movieNights') loadMovieNights();
        }

        async function loadMembers() {
            if (!currentGroupId) return;
            const addMemberForm = document.querySelector('.add-member-form');
            if (addMemberForm) addMemberForm.style.display = hasMinimumRole('moderator') ? '' : 'none';

            if (memberPermissionHint) {
                memberPermissionHint.textContent = hasMinimumRole('moderator')
                    ? 'You can invite members and manage removals based on your role.'
                    : 'Only moderators and owners can invite or remove members.';
            }

            try {
                const members = normalizeCollection(await getGroupMembers(currentGroupId))
                    .map((member) => ({
                        ...member,
                        role: normalizeRole(member.role || (Number(member.user_id) === Number(currentUser?.id) && currentGroupRole === 'owner'
                            ? 'owner'
                            : 'member')),
                    }))
                    .sort((a, b) => {
                        const roleDiff = (GROUP_ROLE_ORDER[b.role] || 0) - (GROUP_ROLE_ORDER[a.role] || 0);
                        if (roleDiff !== 0) return roleDiff;
                        return new Date(a.joined_at).getTime() - new Date(b.joined_at).getTime();
                    });

                if (members.length === 0) {
                    membersList.innerHTML = '<li class="empty-state card">No members yet</li>';
                    return;
                }

                membersList.innerHTML = members.map((member) => `
                    <li class="member-item card">
                        <div class="member-info">
                            <div class="member-name">${escapeHtml(member.name)}</div>
                            <div class="member-email">${escapeHtml(member.email)}</div>
                        </div>
                        <div class="member-role-controls">
                            <span class="member-role-badge role-${member.role}">${formatRole(member.role)}</span>
                            ${currentGroupRole === 'owner' && Number(member.user_id) !== Number(currentUser?.id) ? `
                                <label class="sr-only" for="role-${member.user_id}">Role for ${escapeHtml(member.name)}</label>
                                <select id="role-${member.user_id}" class="member-role-select" data-member-id="${member.user_id}">
                                    <option value="member" ${member.role === 'member' ? 'selected' : ''}>Member</option>
                                    <option value="moderator" ${member.role === 'moderator' ? 'selected' : ''}>Moderator</option>
                                    <option value="owner" ${member.role === 'owner' ? 'selected' : ''}>Owner</option>
                                </select>
                            ` : ''}
                            ${hasMinimumRole('moderator')
                                && Number(member.user_id) !== Number(currentUser?.id)
                                && member.role !== 'owner'
                                && (currentGroupRole === 'owner' || member.role === 'member') ? `
                                <button class="btn btn-ghost js-remove-member" data-member-id="${member.user_id}" type="button">Remove</button>
                            ` : ''}
                        </div>
                    </li>
                `).join('');
            } catch (error) {
                membersList.innerHTML = '<li class="empty-state card">Error loading members</li>';
            }
        }

        async function handleMemberRoleChange(event) {
            const select = event.target.closest('.member-role-select');
            if (!select || !currentGroupId || !hasMinimumRole('owner')) return;

            const memberId = Number(select.dataset.memberId);
            const role = normalizeRole(select.value);
            if (!memberId) return;

            try {
                await updateGroupMemberRole(currentGroupId, memberId, role);
                showSuccess(document.getElementById('memberSuccess'), role === 'owner' ? 'Ownership transferred successfully' : 'Role updated');
                await loadGroups();
                syncCurrentGroupRoleFromCache();
                await loadMembers();
            } catch (error) {
                showError(document.getElementById('memberError'), error.message || 'Failed to update role');
                await loadMembers();
            }
        }

        async function handleMemberRemoval(event) {
            const removeButton = event.target.closest('.js-remove-member');
            if (!removeButton || !currentGroupId || !hasMinimumRole('moderator')) return;

            const memberId = Number(removeButton.dataset.memberId);
            if (!memberId) return;
            if (!confirm('Remove this member from the group?')) return;

            try {
                await removeGroupMember(currentGroupId, memberId);
                showSuccess(document.getElementById('memberSuccess'), 'Member removed');
                await loadGroups();
                syncCurrentGroupRoleFromCache();
                await loadMembers();
            } catch (error) {
                showError(document.getElementById('memberError'), error.message || 'Failed to remove member');
            }
        }

        async function handleAddMember() {
            const email = document.getElementById('memberEmailInput').value.trim();
            const successDiv = document.getElementById('memberSuccess');
            const errorDiv = document.getElementById('memberError');

            if (!currentGroupId) {
                showError(errorDiv, 'Select a group before inviting members');
                return;
            }

            if (!hasMinimumRole('moderator')) {
                showError(errorDiv, 'Only moderators and owners can invite members');
                return;
            }

            if (!email) {
                showError(errorDiv, 'Please enter an email address');
                return;
            }

            try {
                await addGroupMember(currentGroupId, email);
                document.getElementById('memberEmailInput').value = '';
                showSuccess(successDiv, 'Member invited successfully');
                loadMembers();
            } catch (error) {
                showError(errorDiv, error.message || 'Failed to add member');
            }
        }

        async function loadWatchlist() {
            if (!currentGroupId) return;
            try {
                const watchlist = normalizeCollection(await getWatchlist(currentGroupId));
                if (watchlist.length === 0) {
                    watchlistVotingGrid.innerHTML = '<div class="empty-state card"><h3>No movies in watchlist</h3><p>Add movies from Binge Bank to start voting.</p></div>';
                    return;
                }
                await displayWatchlistWithVoting(watchlist);
            } catch (error) {
                watchlistVotingGrid.innerHTML = '<div class="empty-state card"><h3>Error loading watchlist</h3></div>';
            }
        }

        async function displayWatchlistWithVoting(watchlist) {
            const currentUserId = currentUser ? currentUser.id : null;
            let html = '';
            for (const movie of watchlist) {
                const votes = normalizeCollection(await getMovieVotes(currentGroupId, movie.movie_id));
                const userVote = currentUserId ? votes.find((v) => v.user_id === currentUserId) : null;
                const avg = votes.length > 0 ? (votes.reduce((sum, v) => sum + v.vote_value, 0) / votes.length).toFixed(1) : '0.0';

                html += `
                    <article class="watchlist-item card">
                        <div class="watchlist-poster">
                            ${movie.poster_url ? `<img src="${movie.poster_url}" alt="${escapeHtml(movie.title)}" loading="lazy" decoding="async">` : '<span>No Poster</span>'}
                        </div>
                        <div class="watchlist-info">
                            <div class="watchlist-title">${escapeHtml(movie.title)}</div>
                            <div class="watchlist-year">${movie.release_year || 'Unknown'}</div>
                            <div class="watchlist-meta">Added by ${escapeHtml(movie.added_by_name || 'Unknown')}</div>
                        </div>
                        <div class="voting-section">
                            <div class="voting-header">
                                <span class="voting-title">Rate this movie</span>
                                <span class="average-rating">${avg}/5</span>
                            </div>
                            <div class="star-rating" data-movie-id="${movie.movie_id}">
                                ${[1, 2, 3, 4, 5].map((rating) => `
                                    <span class="star ${userVote && userVote.vote_value >= rating ? 'active' : ''}" data-rating="${rating}" onclick="voteMovie(${movie.movie_id}, ${rating})">*</span>
                                `).join('')}
                            </div>
                            <div class="your-vote">${userVote ? `Your vote: ${userVote.vote_value}/5` : 'Click stars to vote'}</div>
                            <div class="vote-stats">
                                <div class="vote-count">${votes.length} vote${votes.length !== 1 ? 's' : ''}</div>
                                ${votes.length > 0 ? `<button class="btn btn-ghost" onclick="toggleVoteBreakdown(${movie.movie_id})" type="button">Breakdown</button>` : ''}
                            </div>
                            <div class="vote-breakdown" id="breakdown-${movie.movie_id}">${generateVoteBreakdown(votes)}</div>
                        </div>
                    </article>
                `;
            }

            watchlistVotingGrid.innerHTML = html;
            setupStarHoverEffects();
        }

        function generateVoteBreakdown(votes) {
            if (votes.length === 0) return '';
            const breakdown = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
            votes.forEach((vote) => { breakdown[vote.vote_value] += 1; });

            return [5, 4, 3, 2, 1].map((rating) => {
                const count = breakdown[rating];
                const percentage = votes.length > 0 ? (count / votes.length) * 100 : 0;
                return `
                    <div class="vote-bar">
                        <span>${rating}</span>
                        <div class="vote-bar-fill"><div class="vote-bar-progress" style="width:${percentage}%"></div></div>
                        <span>${count}</span>
                    </div>
                `;
            }).join('');
        }

        async function voteMovie(movieId, rating) {
            try {
                await voteOnMovie(currentGroupId, movieId, rating);
                await loadWatchlist();
                if (typeof showToast === 'function') showToast(`Voted ${rating}/5`, 'success');
            } catch (error) {
                if (typeof showToast === 'function') showToast(error.message || 'Failed to record vote', 'error');
            }
        }

        function setupStarHoverEffects() {
            document.querySelectorAll('.star-rating').forEach((ratingContainer) => {
                const stars = ratingContainer.querySelectorAll('.star');
                stars.forEach((star, index) => {
                    star.addEventListener('mouseenter', () => {
                        stars.forEach((s, i) => s.classList.toggle('hover', i <= index));
                    });
                    star.addEventListener('mouseleave', () => {
                        stars.forEach((s) => s.classList.remove('hover'));
                    });
                });
            });
        }

        function toggleVoteBreakdown(movieId) {
            const breakdown = document.getElementById(`breakdown-${movieId}`);
            if (breakdown) breakdown.classList.toggle('show');
        }

        async function loadWatchlistMovies() {
            if (!currentGroupId) return;
            try {
                const watchlist = normalizeCollection(await getWatchlist(currentGroupId));
                const select = document.getElementById('chosenMovie');
                select.innerHTML = '<option value="">Select a movie from watchlist...</option>';
                watchlist.forEach((movie) => {
                    select.innerHTML += `<option value="${movie.movie_id}">${escapeHtml(movie.title)} (${movie.release_year || 'Unknown'})</option>`;
                });
            } catch (error) {
                console.error('Error loading watchlist for dropdown:', error);
            }
        }

        async function loadMovieNights() {
            if (!currentGroupId) return;
            try {
                const movieNights = normalizeCollection(await getMovieNights(currentGroupId));
                const plannedCount = movieNights.filter((night) => night.status === 'planned').length;
                movieNightPlanCount.textContent = `${plannedCount} planned`;
                movieNightsCache = movieNights;
                renderMovieNightCalendar(movieNights);

                if (movieNights.length === 0) {
                    movieNightsList.innerHTML = '<li class="empty-state card">No movie nights scheduled yet</li>';
                    updateCalendarDaySummary(movieNightDateInput.value);
                    return;
                }

                movieNightsList.innerHTML = movieNights.map((night) => `
                    <li class="movie-night-item card">
                        <div class="movie-night-header">
                            <div class="movie-night-date">${formatDateTime(night.scheduled_date)}</div>
                            <div class="movie-night-header-tags">
                                <div class="movie-night-status status-${night.status}">${night.status}</div>
                                <div class="movie-night-lock ${night.is_locked ? 'is-locked' : 'is-open'}">${night.is_locked ? 'Locked' : 'Open'}</div>
                            </div>
                        </div>
                        <div class="movie-night-movie">${night.movie_title ? `Movie: ${escapeHtml(night.movie_title)}` : 'No movie selected yet'}</div>
                        <div class="movie-night-rsvp-meta">
                            <p class="movie-night-rsvp-countdown">${formatRsvpCountdown(night.rsvp_deadline)}</p>
                            <p class="movie-night-rsvp-note">${night.reminder_minutes_before ? `Auto reminder ${formatReminderLeadLabel(night.reminder_minutes_before)}` : 'No automatic reminder configured'}</p>
                            <div class="awaiting-row">
                                <span class="awaiting-label">${Number(night.pending_rsvp_count || 0)} awaiting response</span>
                                <div class="awaiting-chips">${renderAwaitingMembersChips(night)}</div>
                            </div>
                        </div>
                        <div class="movie-night-actions">
                            ${hasMinimumRole('moderator') ? `
                                <button
                                    class="btn btn-ghost js-toggle-lock"
                                    data-night-id="${night.night_id}"
                                    data-locked="${night.is_locked ? '1' : '0'}"
                                    type="button"
                                >${night.is_locked ? 'Unlock Schedule' : 'Lock Schedule'}</button>
                            ` : ''}
                            ${hasMinimumRole('moderator') && night.rsvp_deadline ? `
                                <button class="btn btn-ghost js-send-rsvp-reminder" data-night-id="${night.night_id}" type="button">Send RSVP Reminder</button>
                            ` : ''}
                            <button class="btn btn-secondary js-export-ics" data-night-id="${night.night_id}" type="button">Export .ics</button>
                        </div>
                    </li>
                `).join('');
            } catch (error) {
                movieNightPlanCount.textContent = '0 planned';
                movieNightsCache = [];
                renderMovieNightCalendar([]);
                movieNightsList.innerHTML = '<li class="empty-state card">Error loading movie nights</li>';
            }
        }

        async function handleCreateMovieNight() {
            const scheduledDate = buildSelectedDateTime();
            const movieSelect = document.getElementById('chosenMovie').value;
            const rsvpDeadline = buildRsvpDeadlineDateTime();
            const reminderMinutesBefore = rsvpReminderMinutesInput.value ? Number(rsvpReminderMinutesInput.value) : null;
            const successDiv = document.getElementById('movieNightSuccess');
            const errorDiv = document.getElementById('movieNightError');

            if (!scheduledDate) {
                showError(errorDiv, 'Please select a calendar date');
                return;
            }

            const selectedDate = parseDateValue(scheduledDate);
            if (!selectedDate || selectedDate.getTime() < Date.now() - 60000) {
                showError(errorDiv, 'Please select a future date and time');
                return;
            }

            let parsedRsvpDeadline = null;
            if (rsvpDeadline) {
                parsedRsvpDeadline = parseDateValue(rsvpDeadline);
                if (!parsedRsvpDeadline) {
                    showError(errorDiv, 'Please provide a valid RSVP deadline');
                    return;
                }
                if (parsedRsvpDeadline.getTime() < Date.now() - 60000) {
                    showError(errorDiv, 'RSVP deadline must be in the future');
                    return;
                }
                if (parsedRsvpDeadline.getTime() >= selectedDate.getTime()) {
                    showError(errorDiv, 'RSVP deadline must be before the movie night start');
                    return;
                }
            }

            if (reminderMinutesBefore && !parsedRsvpDeadline) {
                showError(errorDiv, 'Select an RSVP deadline before enabling reminders');
                return;
            }

            const payload = {};
            if (rsvpDeadline) payload.rsvpDeadline = rsvpDeadline;
            if (reminderMinutesBefore) payload.reminderMinutesBefore = reminderMinutesBefore;

            try {
                await createMovieNight(currentGroupId, scheduledDate, movieSelect || null, payload);
                document.getElementById('chosenMovie').value = '';
                rsvpDeadlineDateInput.value = '';
                rsvpDeadlineTimeInput.value = '18:00';
                rsvpReminderMinutesInput.value = '';
                updateSelectedDatePreview();
                showSuccess(successDiv, 'Movie night scheduled');
                await loadMovieNights();
            } catch (error) {
                showError(errorDiv, error.message || 'Failed to create movie night');
            }
        }

        async function handleMovieNightsListActions(event) {
            const reminderButton = event.target.closest('.js-send-rsvp-reminder');
            if (reminderButton && currentGroupId && hasMinimumRole('moderator')) {
                const nightId = Number(reminderButton.dataset.nightId);
                if (!nightId) return;

                reminderButton.disabled = true;
                const originalLabel = reminderButton.textContent;
                reminderButton.textContent = 'Sending...';

                try {
                    const result = await sendRsvpReminder(currentGroupId, nightId, true);
                    const recipientCount = Number(result && result.recipients ? result.recipients : 0);
                    showSuccess(
                        document.getElementById('movieNightSuccess'),
                        recipientCount > 0 ? `RSVP reminder sent to ${recipientCount} member${recipientCount === 1 ? '' : 's'}` : 'RSVP reminder processed'
                    );
                    await loadMovieNights();
                } catch (error) {
                    showError(document.getElementById('movieNightError'), error.message || 'Failed to send RSVP reminder');
                    reminderButton.disabled = false;
                    reminderButton.textContent = originalLabel;
                }
                return;
            }

            const lockButton = event.target.closest('.js-toggle-lock');
            if (lockButton && currentGroupId && hasMinimumRole('moderator')) {
                const nightId = Number(lockButton.dataset.nightId);
                const currentlyLocked = lockButton.dataset.locked === '1';
                if (!nightId) return;

                lockButton.disabled = true;
                const originalLabel = lockButton.textContent;
                lockButton.textContent = currentlyLocked ? 'Unlocking...' : 'Locking...';

                try {
                    await setMovieNightLock(currentGroupId, nightId, !currentlyLocked);
                    showSuccess(document.getElementById('movieNightSuccess'), currentlyLocked ? 'Movie night unlocked' : 'Movie night locked');
                    await loadMovieNights();
                } catch (error) {
                    showError(document.getElementById('movieNightError'), error.message || 'Failed to update lock status');
                    lockButton.disabled = false;
                    lockButton.textContent = originalLabel;
                }
                return;
            }

            const exportButton = event.target.closest('.js-export-ics');
            if (!exportButton || !currentGroupId) return;

            const nightId = Number(exportButton.dataset.nightId);
            if (!nightId) return;

            const originalLabel = exportButton.textContent;
            exportButton.disabled = true;
            exportButton.textContent = 'Preparing...';

            try {
                const { blob, filename } = await exportMovieNightIcs(currentGroupId, nightId);
                triggerFileDownload(blob, filename);
                showSuccess(null, 'Calendar invite exported');
            } catch (error) {
                showError(document.getElementById('movieNightError'), error.message || 'Failed to export .ics');
            } finally {
                exportButton.disabled = false;
                exportButton.textContent = originalLabel;
            }
        }

        function triggerFileDownload(blob, filename) {
            const objectUrl = URL.createObjectURL(blob);
            const downloadLink = document.createElement('a');
            downloadLink.href = objectUrl;
            downloadLink.download = filename || 'movie-night.ics';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            downloadLink.remove();
            setTimeout(() => URL.revokeObjectURL(objectUrl), 0);
        }

        function showError(element, message) {
            if (!element) return;
            element.textContent = message;
            element.style.display = 'block';
            setTimeout(() => { element.style.display = 'none'; }, 5000);
            if (typeof showToast === 'function') showToast(message, 'error');
        }

        function showSuccess(element, message) {
            if (element) {
                element.textContent = message;
                element.style.display = 'block';
                setTimeout(() => { element.style.display = 'none'; }, 3000);
            }
            if (typeof showToast === 'function') showToast(message, 'success');
        }
    </script>
</body>
</html>
